#!/bin/bash

#############################
## 场景一：判断变量是否为空##
#############################
a=abc
echo $a

[ $a ]
echo $?

[[ $a ]] 
echo $?

b=''''
echo $b

[ $b ]
echo $?

[[ $b ]]
echo $?

#上述，变量值非空时返回真（即返回值为0），使用上述方法判断变量值是否为空时，[]与[[]]没有区别，变量值非空，返回真，
#我们可以使用“！”进行取反，使得变量值为空 

echo $c

[ ! $c ]
echo $? 

[[ ! $c ]]
echo $?

! [ $c ]
echo $?

! [[ $c ]]
echo $?

#上述，变量c是一个没有被声明赋值的变量，其值为空，我们可以使用上述语法，判断变量c的值是否为空，
#变量值为空，返回真，同理，上述示例，[]与[[]]没有区别
#那到底 []与[[]]的区别在哪里呢？

#再linux中，我们可以使用test命令来判断一个字符串是否为空，test命令为我们提供了“-z选项”与“-n选项”，使用这两个选项可以判断字符串是否为空。
#“-z” 可以判断指定的字符串是否为空，为空则返回真，非空则返回假，-z可以理解为zero
#“-n” 可以判断指定的字符串是否为空，非空则返回真，为空则返回假，-n可以理解为nozero
#“-n” 也可以理解为 指定的字符串是一个不空字符（非空字符），若字符串是个非空字符为真，若字符串是个空字符为假。

test -z ""
echo $?

test -z "abc"
echo $?

test -n "abc"
echo $?

test -n ""
echo $?

#上述，我们通过test命令判断了字符串是否为空，那么我们再尝试一下，使用test命令判断变量的值是否为空：

a=abc
echo $a

echo $b

test -z $b
echo $?

test -z $a
echo $?

test -n $a
echo $?

test -n $b  #按逻辑来说 这个的echo 为1，因为判断$b是否是一个不空字符，空为假，应该返回1，但是结果返回了0 
echo $?     #这明显是不正确的，所以，为了防止上述情况的发生，在使用test命令的-n选项判断变量的值是否为空时，
            #需要在变量的外侧加上“双引号“，示例如下：

echo $b

test -n $b  #错误 
echo $?

test -n "$b" #正确
echo $?

#之所以前面介绍test，是因为，在Linux中，”[]“与”test“命令是等效的，比如，我们也可以使用”-n“或者”-z“结合”[]“去判断变量是否为空
a=abc
echo $a

echo $b

[ -n "$a" ]
echo $?

[ -n "$b" ]
echo $?

[ -n $b ]  #错误
echo $？

#上述，当”[]“中使用”-n“ 或者 ”-z“ 这些选项判断是否为空时，必须在变量的外侧加上双引号，才更加保险，与”test“命令的使用方法相同。
#不过，使用”[[]]“时则不用考虑这样的问题，示例如下：

a=abc
echo $a

echo $b

[[ -n $a ]]
echo $?

[[ -n $b ]]
echo $?

[[ -z $b ]]
echo $?

[[ -z $a ]]
echo $?

#综上所述，我们可以得出一下结论：
#当使用”-n“或者”-z“这种方式判断变量是否为空时，”[]“与”[[]]“是有区别的。
#使用”[]“时需要在变量的外侧加上双引号，与test命令的用法完全相同，使用”[[]]“时则不同。



########################
##场景二：组合判断条件##
########################

#在shell中，我们可以使用”-a“或者”-o“对多个条件进行连接，然后进行”与运算“或者”或运算“，
#也可以使用”&&“或者”||“对多个条件进行链接，但是，这两种方法对于"[]"或者”[[]]“来说，是存在问题的!
#如下所示：

[[ 3 -gt 1 && 5 -lt 8 ]]
echo $?

[[ 5 -gt 2 || 9 -lt 3 ]]
echo $?

[[ 3 -gt 1 ]] && [[ 5 -lt 8 ]]
echo $?

[[ 5 -gt 2 ]] || [[ 9 -lt 3 ]]
echo $?

#如上图所示，当使用”[[]]“对多个条件进行”与运算“或者”或运算“时，可以一次性将多个条件包含在一个”[[]]“中，
#然后将每个条件用”&&“或者用”||“连接起来，或者每个条件分别包含在一个”[[]]“中，然后再用”&&“或者用”||“连接起来，
#正如上图所示，这两种写法都没问题

#那么，使用”[[]]“时，是否使用”-a“或者”-o“对多个条件进行连接呢？示例如下：

#[[ 3 -gt 1 -a 5 -lt -8 ]]

#[[ 3 -gt 1]] -a [[ 5 -lt 8 ]]

#[[ 5 -gt 2 -o 9 -lt 3 ]]

#[[ 5 -gt 2 ]] -o [[ 9 -lt 3 ]]

#事实证明，使用”[[]]“时，是不能使用”-a“或者”-o“对多个条件进行连接的。

#仍然使用上述示例，我们将”[[]]“换成”[]“ 试试：
[ 3 -gt 1 -a 5 -lt -8 ]

[ 3 -gt 1] -a [ 5 -lt 8]

[ 5 -gt 2 -o 9 -lt 3 ]

[ 5 -gt 2 ] -o [ 9 -lt 3 ]

#看来，当时用”[]“时，如果使用”-a“或者”-o“对多个条件进行连接，”-a“或者”-o“必须被包含在”[]“之内，
#才能够正常使用，否则会报语法错误

#”-a“或者”-o“的使用方法我们已经在”[]“中进行验证，现在，我们来试试”&&“或者”||“在"[]“中的使用方法，
#示例如下：
[ 3 -gt 1 && 5 -lt 8 ]

[ 3 -gt 1 ] && [ 5 -lt 8 ]
echo $?

[ 5 -gt 2 || 9 -lt 3 ]

[ 5 -gt 2 ] || [ 9 -lt 3 ]
echo $?

#从上述可知，与”-a“和”-o“的使用方法正好相反，当使用”[]“时，如果使用”&&“或者”||“对多个条件进行连接，
#”&&“或者”||“必须在”[]“之外，否则会报语法错误

#综上所述，我们可以总结出如下结论：
#在使用”[[]]“时，不能使用”-a“或者”-o“对多个条件进行连接。
#在使用”[]“时，如果使用”-a“或者”-o“对多个条件进行连接，”-a“或者”-o“必须被包含在"[]”之内。
#在使用“[]”时，如果使用“&&”或者“||”对多个条件进行连接，“&&”或者“||”必须在“[]”之外。


######################
##场景三：某些运算符##
######################

tel=13688888888
[[ $tel =~[0-9]{11} ]]
echo $?

tel=1368888888k
[[ $tel =~[0-9]{11} ]]
echo $？

#上述，我们通过“=~”，可以判断一个变量的值是否匹配对应的正则表达式，
#若把[[]] 换成[]

tel=13688888888
[ $tel = ~[0-9]{11} ]

